/**
 * @license
 * Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
 * This code may only be used under the BSD style license found at
 * http://polymer.github.io/LICENSE.txt
 * The complete set of authors may be found at
 * http://polymer.github.io/AUTHORS.txt
 * The complete set of contributors may be found at
 * http://polymer.github.io/CONTRIBUTORS.txt
 * Code distributed by Google as part of the polymer project is also
 * subject to an additional IP rights grant found at
 * http://polymer.github.io/PATENTS.txt
 */const directives=new WeakMap,directive=a=>(directives.set(a,!0),a),isDirective=a=>"function"==typeof a&&directives.has(a),isCEPolyfill=window.customElements!==void 0&&window.customElements.polyfillWrapFlushCallback!==void 0,reparentNodes=(a,b,c=null,d=null)=>{for(let e=b;e!==c;){const b=e.nextSibling;a.insertBefore(e,d),e=b}},removeNodes=(a,b,c=null)=>{for(let d=b;d!==c;){const b=d.nextSibling;a.removeChild(d),d=b}},noChange={},marker=`{{lit-${(Math.random()+"").slice(2)}}}`,nodeMarker=`<!--${marker}-->`,markerRegex=new RegExp(`${marker}|${nodeMarker}`),rewritesStyleAttribute=(()=>{const a=document.createElement("div");return a.setAttribute("style","{{bad value}}"),"{{bad value}}"!==a.getAttribute("style")})();class Template{constructor(a,b){this.parts=[],this.element=b;let c=-1,d=0;const e=[],f=b=>{const g=b.content,h=document.createTreeWalker(g,133,null,!1);let i,j;for(;h.nextNode();){c++,i=j;const b=j=h.currentNode;if(1===b.nodeType){if(b.hasAttributes()){const e=b.attributes;let f=0;for(let a=0;a<e.length;a++)0<=e[a].value.indexOf(marker)&&f++;for(;0<f--;){const e=a.strings[d],f=lastAttributeNameRegex.exec(e)[2],g=rewritesStyleAttribute&&"style"===f?"style$":/^[a-zA-Z-]*$/.test(f)?f:f.toLowerCase(),h=b.getAttribute(g),i=h.split(markerRegex);this.parts.push({type:"attribute",index:c,name:f,strings:i}),b.removeAttribute(g),d+=i.length-1}}"TEMPLATE"===b.tagName&&f(b)}else if(3===b.nodeType){const a=b.nodeValue;if(0>a.indexOf(marker))continue;const f=b.parentNode,g=a.split(markerRegex),h=g.length-1;d+=h;for(let a=0;a<h;a++)f.insertBefore(""===g[a]?createMarker():document.createTextNode(g[a]),b),this.parts.push({type:"node",index:c++});f.insertBefore(""===g[h]?createMarker():document.createTextNode(g[h]),b),e.push(b)}else if(8===b.nodeType)if(b.nodeValue===marker){const a=b.parentNode,f=b.previousSibling;null===f||f!==i||f.nodeType!==Node.TEXT_NODE?a.insertBefore(createMarker(),b):c--,this.parts.push({type:"node",index:c++}),e.push(b),null===b.nextSibling?a.insertBefore(createMarker(),b):c--,j=i,d++}else for(let a=-1;-1!==(a=b.nodeValue.indexOf(marker,a+1));)this.parts.push({type:"node",index:-1})}};f(b);for(const c of e)c.parentNode.removeChild(c)}}const isTemplatePartActive=a=>-1!==a.index,createMarker=()=>document.createComment(""),lastAttributeNameRegex=/([ \x09\x0a\x0c\x0d])([^\0-\x1F\x7F-\x9F \x09\x0a\x0c\x0d"'>=/]+)([ \x09\x0a\x0c\x0d]*=[ \x09\x0a\x0c\x0d]*(?:[^ \x09\x0a\x0c\x0d"'`<>=]*|"[^"]*|'[^']*))$/;class TemplateInstance{constructor(a,b,c){this._parts=[],this.template=a,this.processor=b,this.options=c}update(a){let b=0;for(const c of this._parts)void 0!==c&&c.setValue(a[b]),b++;for(const b of this._parts)void 0!==b&&b.commit()}_clone(){const a=isCEPolyfill?this.template.element.content.cloneNode(!0):document.importNode(this.template.element.content,!0),b=this.template.parts;let c=0,d=0;const e=a=>{const f=document.createTreeWalker(a,133,null,!1);for(let g=f.nextNode();c<b.length&&null!==g;){const a=b[c];if(!isTemplatePartActive(a))this._parts.push(void 0),c++;else if(d===a.index){if("node"===a.type){const a=this.processor.handleTextExpression(this.options);a.insertAfterNode(g),this._parts.push(a)}else this._parts.push(...this.processor.handleAttributeExpressions(g,a.name,a.strings,this.options));c++}else d++,"TEMPLATE"===g.nodeName&&e(g.content),g=f.nextNode()}};return e(a),isCEPolyfill&&(document.adoptNode(a),customElements.upgrade(a)),a}}class TemplateResult{constructor(a,b,c,d){this.strings=a,this.values=b,this.type=c,this.processor=d}getHTML(){const a=this.strings.length-1;let b="",c=!0;for(let d=0;d<a;d++){const a=this.strings[d];b+=a;const e=a.lastIndexOf(">");c=(-1<e||c)&&-1===a.indexOf("<",e+1),!c&&rewritesStyleAttribute&&(b=b.replace(lastAttributeNameRegex,(a,b,c,d)=>"style"===c?`${b}style$${d}`:a)),b+=c?nodeMarker:marker}return b+=this.strings[a],b}getTemplateElement(){const a=document.createElement("template");return a.innerHTML=this.getHTML(),a}}class SVGTemplateResult extends TemplateResult{getHTML(){return`<svg>${super.getHTML()}</svg>`}getTemplateElement(){const a=super.getTemplateElement(),b=a.content,c=b.firstChild;return b.removeChild(c),reparentNodes(b,c.firstChild),a}}const isPrimitive=a=>null===a||"object"!=typeof a&&"function"!=typeof a;class AttributeCommitter{constructor(a,b,c){this.dirty=!0,this.element=a,this.name=b,this.strings=c,this.parts=[];for(let d=0;d<c.length-1;d++)this.parts[d]=this._createPart()}_createPart(){return new AttributePart(this)}_getValue(){const a=this.strings,b=a.length-1;let c="";for(let d=0;d<b;d++){c+=a[d];const b=this.parts[d];if(void 0!==b){const a=b.value;if(null!=a&&(Array.isArray(a)||"string"!=typeof a&&a[Symbol.iterator]))for(const b of a)c+="string"==typeof b?b:b+"";else c+="string"==typeof a?a:a+""}}return c+=a[b],c}commit(){this.dirty&&(this.dirty=!1,this.element.setAttribute(this.name,this._getValue()))}}class AttributePart{constructor(a){this.value=void 0,this.committer=a}setValue(a){a===noChange||isPrimitive(a)&&a===this.value||(this.value=a,!isDirective(a)&&(this.committer.dirty=!0))}commit(){for(;isDirective(this.value);){const a=this.value;this.value=noChange,a(this)}this.value===noChange||this.committer.commit()}}class NodePart{constructor(a){this.value=void 0,this._pendingValue=void 0,this.options=a}appendInto(a){this.startNode=a.appendChild(createMarker()),this.endNode=a.appendChild(createMarker())}insertAfterNode(a){this.startNode=a,this.endNode=a.nextSibling}appendIntoPart(a){a._insert(this.startNode=createMarker()),a._insert(this.endNode=createMarker())}insertAfterPart(a){a._insert(this.startNode=createMarker()),this.endNode=a.endNode,a.endNode=this.startNode}setValue(a){this._pendingValue=a}commit(){for(;isDirective(this._pendingValue);){const a=this._pendingValue;this._pendingValue=noChange,a(this)}const a=this._pendingValue;a===noChange||(isPrimitive(a)?a!==this.value&&this._commitText(a):a instanceof TemplateResult?this._commitTemplateResult(a):a instanceof Node?this._commitNode(a):Array.isArray(a)||a[Symbol.iterator]?this._commitIterable(a):a.then===void 0?this._commitText(a):this._commitPromise(a))}_insert(a){this.endNode.parentNode.insertBefore(a,this.endNode)}_commitNode(a){this.value===a||(this.clear(),this._insert(a),this.value=a)}_commitText(a){const b=this.startNode.nextSibling;a=null==a?"":a,b===this.endNode.previousSibling&&b.nodeType===Node.TEXT_NODE?b.textContent=a:this._commitNode(document.createTextNode("string"==typeof a?a:a+"")),this.value=a}_commitTemplateResult(a){const b=this.options.templateFactory(a);if(this.value&&this.value.template===b)this.value.update(a.values);else{const c=new TemplateInstance(b,a.processor,this.options),d=c._clone();c.update(a.values),this._commitNode(d),this.value=c}}_commitIterable(a){Array.isArray(this.value)||(this.value=[],this.clear());const b=this.value;let c,d=0;for(const e of a)c=b[d],void 0===c&&(c=new NodePart(this.options),b.push(c),0==d?c.appendIntoPart(this):c.insertAfterPart(b[d-1])),c.setValue(e),c.commit(),d++;d<b.length&&(b.length=d,this.clear(c&&c.endNode))}_commitPromise(a){this.value=a,a.then(b=>{this.value===a&&(this.setValue(b),this.commit())})}clear(a=this.startNode){removeNodes(this.startNode.parentNode,a.nextSibling,this.endNode)}}class BooleanAttributePart{constructor(a,b,c){if(this.value=void 0,this._pendingValue=void 0,2!==c.length||""!==c[0]||""!==c[1])throw new Error("Boolean attributes can only contain a single expression");this.element=a,this.name=b,this.strings=c}setValue(a){this._pendingValue=a}commit(){for(;isDirective(this._pendingValue);){const a=this._pendingValue;this._pendingValue=noChange,a(this)}if(this._pendingValue!==noChange){const a=!!this._pendingValue;this.value!==a&&(a?this.element.setAttribute(this.name,""):this.element.removeAttribute(this.name)),this.value=a,this._pendingValue=noChange}}}class PropertyCommitter extends AttributeCommitter{constructor(a,b,c){super(a,b,c),this.single=2===c.length&&""===c[0]&&""===c[1]}_createPart(){return new PropertyPart(this)}_getValue(){return this.single?this.parts[0].value:super._getValue()}commit(){this.dirty&&(this.dirty=!1,this.element[this.name]=this._getValue())}}class PropertyPart extends AttributePart{}let eventOptionsSupported=!1;try{const a={get capture(){return eventOptionsSupported=!0,!1}};window.addEventListener("test",a,a),window.removeEventListener("test",a,a)}catch(a){}class EventPart{constructor(a,b,c){this.value=void 0,this._pendingValue=void 0,this.element=a,this.eventName=b,this.eventContext=c}setValue(a){this._pendingValue=a}commit(){for(;isDirective(this._pendingValue);){const a=this._pendingValue;this._pendingValue=noChange,a(this)}if(this._pendingValue===noChange)return;const a=this._pendingValue,b=this.value,c=null==a||null!=b&&(a.capture!==b.capture||a.once!==b.once||a.passive!==b.passive);c&&this.element.removeEventListener(this.eventName,this,this._options),this._options=getOptions(a),null!=a&&(null==b||c)&&this.element.addEventListener(this.eventName,this,this._options),this.value=a,this._pendingValue=noChange}handleEvent(a){const b="function"==typeof this.value?this.value:"function"==typeof this.value.handleEvent?this.value.handleEvent:()=>null;b.call(this.eventContext||this.element,a)}}const getOptions=a=>a&&(eventOptionsSupported?{capture:a.capture,passive:a.passive,once:a.once}:a.capture);class DefaultTemplateProcessor{handleAttributeExpressions(a,b,c,d){const e=b[0];if("."===e){const d=new PropertyCommitter(a,b.slice(1),c);return d.parts}if("@"===e)return[new EventPart(a,b.slice(1),d.eventContext)];if("?"===e)return[new BooleanAttributePart(a,b.slice(1),c)];const f=new AttributeCommitter(a,b,c);return f.parts}handleTextExpression(a){return new NodePart(a)}}const defaultTemplateProcessor=new DefaultTemplateProcessor;function templateFactory(a){let b=templateCaches.get(a.type);void 0===b&&(b=new Map,templateCaches.set(a.type,b));let c=b.get(a.strings);return void 0===c&&(c=new Template(a,a.getTemplateElement()),b.set(a.strings,c)),c}const templateCaches=new Map,parts=new WeakMap,render=(a,b,c)=>{let d=parts.get(b);d===void 0&&(removeNodes(b,b.firstChild),parts.set(b,d=new NodePart(Object.assign({templateFactory},c))),d.appendInto(b)),d.setValue(a),d.commit()},html=(a,...b)=>new TemplateResult(a,b,"html",defaultTemplateProcessor),svg=(a,...b)=>new SVGTemplateResult(a,b,"svg",defaultTemplateProcessor);export{html,svg,TemplateResult,SVGTemplateResult,marker,nodeMarker,markerRegex,rewritesStyleAttribute,Template,isTemplatePartActive,createMarker,lastAttributeNameRegex,DefaultTemplateProcessor,defaultTemplateProcessor,TemplateInstance,noChange,isPrimitive,AttributeCommitter,AttributePart,NodePart,BooleanAttributePart,PropertyCommitter,PropertyPart,EventPart,isCEPolyfill,reparentNodes,removeNodes,directive,isDirective,parts,render,templateFactory,templateCaches};